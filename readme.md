# Smart Pointers

## Что за умные указатели такие?

Иногда объект, созданный на хипе, нужно передавать в кучу функций, методов, etc.
В такой ситуации становится сложно уследить за лайфтаймом объекта и моментом, 
когда нужно освобождать выделенную под объект память.

Хотелось бы воспользоваться удобной обёрткой,
которая автоматически выделит память при создании объекта
и освободит память, когда объект больше не используется --- 
ровно для этого и существуют умные указатели.

Умные указатели бывают разные. 
В рамках этого проекта я рассмотрел три типа, которые отличаются между собой 
семантикой владения:
* ```UniquePtr``` является единственным владельцем объекта.
* ```SharedPtr``` позволяет множественное владение.
* ```IntrusivePtr``` позволяет множественное владение, как и `SharedPtr`; использование `IntrusivePtr` накладывает определенные ограничения на пользовательский тип.


### ```UniquePtr```

   * Реализовал базовую функциональность ```UniquePtr```.
   * Добавил ```Deleter``` (функтор, который вызывается для объекта в 
   деструкторе указателя).
   * Интегрировал ```CompressedPair``` для ```Deleter```.
   * Специализировал шаблон для массивов --- ```UniquePtr<T[]>```.

### ```SharedPtr```

   * Реализовал базовую функциональность ```SharedPtr```.
   * Добавил оптимизированный ```MakeShared``` (одна аллокация на 
   контрольный блок и элемент).

### ```WeakPtr```
  Младший брат SharedPtr, который расширяет функционал SharedPtr

### ```Shared From This```

Здесь реализовал ```EnableSharedFromThis``` - способ создать ```SharedPtr```,
   имея лишь ```this```.


### ```IntrusivePtr```

   * Реализовал базовую функциональность ```IntrusivePtr```.
   * Добавил удобную функцию ```MakeIntrusive```.



